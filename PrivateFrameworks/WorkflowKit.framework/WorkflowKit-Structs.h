/*
* This header is generated by classdump-dyld 1.0
* on Thursday, September 24, 2020 at 12:45:04 AM British Summer Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/WorkflowKit.framework/WorkflowKit
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013-2016 by Elias Limneos.
*/

typedef struct Handle<realm::_impl::CollectionNotifier> {
	CollectionNotifier __ptr_;
	__shared_weak_count __cntrl_;
} Handle<realm::_impl::CollectionNotifier>;

typedef struct BasicTableRef<realm::Table> {
	Table m_ptr;
} BasicTableRef<realm::Table>;

typedef struct shared_ptr<realm::LinkView> {
	LinkView __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<realm::LinkView>;

typedef struct shared_ptr<realm::Realm> {
	Realm __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<realm::Realm>;

typedef struct List {
	shared_ptr<realm::Realm> m_realm;
	ObjectSchema m_object_schema;
	shared_ptr<realm::LinkView> m_link_view;
	BasicTableRef<realm::Table> m_table;
	Handle<realm::_impl::CollectionNotifier> m_notifier;
} List;

typedef struct _compressed_pair<RLMObservationInfo *, std::__1::default_delete<RLMObservationInfo> > {
	RLMObservationInfo __value_;
} compressed_pair<RLMObservationInfo *, std::__1::default_delete<RLMObservationInfo> >;

typedef struct unique_ptr<RLMObservationInfo, std::__1::default_delete<RLMObservationInfo> > {
	compressed_pair<RLMObservationInfo *, std::__1::default_delete<RLMObservationInfo> > __ptr_;
} unique_ptr<RLMObservationInfo, std::__1::default_delete<RLMObservationInfo> >;

typedef struct {
	unsigned long long field1;
	id field2;
	unsigned long long field3;
	unsigned long long field4[5];
} SCD_Struct_RL7;

typedef struct _compressed_pair<__strong id *, std::__1::default_delete<id []> > {
	id __value_;
} compressed_pair<__strong id *, std::__1::default_delete<id []> >;

typedef struct unique_ptr<id [], std::__1::default_delete<id []> > {
	compressed_pair<__strong id *, std::__1::default_delete<id []> > __ptr_;
} unique_ptr<id [], std::__1::default_delete<id []> >;

typedef struct _long {
	char* __data_;
	unsigned long long __size_;
	unsigned long long __cap_;
} long;

typedef struct {
	unsigned char __size_;
} SCD_Struct_RL11;

typedef struct _raw {
	unsigned long long __words[3];
} raw;

typedef struct _compressed_pair<unsigned long *, std::__1::allocator<unsigned long> > {
	unsigned long long __value_;
} compressed_pair<unsigned long *, std::__1::allocator<unsigned long> >;

typedef struct Optional<unsigned long long> {
	/*function pointer*/void* ;
	unsigned long long m_value;
	c) m_null_state;
	BOOL m_engaged;
} Optional<unsigned long long>;

typedef struct Handle<realm::_impl::ResultsNotifier> {
	ResultsNotifier __ptr_;
	__shared_weak_count __cntrl_;
} Handle<realm::_impl::ResultsNotifier>;

typedef struct _compressed_pair<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > *, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > > {
	unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > __value_;
} compressed_pair<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > *, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > >;

typedef struct vector<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> >, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > > {
	unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > __begin_;
	unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > __end_;
	compressed_pair<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > *, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > > __end_cap_;
} vector<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> >, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > >;

typedef struct DescriptorOrdering {
	vector<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> >, std::__1::allocator<std::__1::unique_ptr<realm::BaseDescriptor, std::__1::default_delete<realm::BaseDescriptor> > > > m_descriptors;
} DescriptorOrdering;

typedef struct shared_ptr<const realm::LinkView> {
	LinkView __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<const realm::LinkView>;

typedef struct _compressed_pair<realm::TableViewBase *, std::__1::default_delete<realm::TableViewBase> > {
	TableViewBase __value_;
} compressed_pair<realm::TableViewBase *, std::__1::default_delete<realm::TableViewBase> >;

typedef struct unique_ptr<realm::TableViewBase, std::__1::default_delete<realm::TableViewBase> > {
	compressed_pair<realm::TableViewBase *, std::__1::default_delete<realm::TableViewBase> > __ptr_;
} unique_ptr<realm::TableViewBase, std::__1::default_delete<realm::TableViewBase> >;

typedef struct shared_ptr<const realm::Descriptor> {
	Descriptor __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<const realm::Descriptor>;

typedef struct vector<unsigned long, std::__1::allocator<unsigned long> > {
	unsigned long long __begin_;
	unsigned long long __end_;
	compressed_pair<unsigned long *, std::__1::allocator<unsigned long> > __end_cap_;
} vector<unsigned long, std::__1::allocator<unsigned long> >;

typedef struct _compressed_pair<realm::QueryGroup *, std::__1::allocator<realm::QueryGroup> > {
	QueryGroup __value_;
} compressed_pair<realm::QueryGroup *, std::__1::allocator<realm::QueryGroup> >;

typedef struct vector<realm::QueryGroup, std::__1::allocator<realm::QueryGroup> > {
	QueryGroup __begin_;
	QueryGroup __end_;
	compressed_pair<realm::QueryGroup *, std::__1::allocator<realm::QueryGroup> > __end_cap_;
} vector<realm::QueryGroup, std::__1::allocator<realm::QueryGroup> >;

typedef struct _short {
	char __data_[23];
	SCD_Struct_RL11 ;
} short;

typedef struct _rep {
	/*function pointer*/void* ;
	long __l;
	short __s;
	const aw) __r;
} rep;

typedef struct _compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > {
	const ep __value_;
} compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >;

typedef struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > {
	compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > __r_;
} basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >;

typedef struct Query {
	basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > error_code;
	vector<realm::QueryGroup, std::__1::allocator<realm::QueryGroup> > m_groups;
	vector<unsigned long, std::__1::allocator<unsigned long> > m_subtable_path;
	shared_ptr<const realm::Descriptor> m_current_descriptor;
	BasicTableRef<realm::Table> m_table;
	RowIndexes m_view;
	shared_ptr<realm::LinkView> m_source_link_view;
	TableViewBase m_source_table_view;
	unique_ptr<realm::TableViewBase, std::__1::default_delete<realm::TableViewBase> > m_owned_source_table_view;
} Query;

typedef struct BasicRow<const realm::Table> {
	BasicTableRef<realm::Table> m_table;
	unsigned long long m_row_ndx;
	RowBase m_prev;
	RowBase m_next;
} BasicRow<const realm::Table>;

typedef struct _compressed_pair<realm::Array *, std::__1::default_delete<realm::Array> > {
	Array __value_;
} compressed_pair<realm::Array *, std::__1::default_delete<realm::Array> >;

typedef struct unique_ptr<realm::Array, std::__1::default_delete<realm::Array> > {
	compressed_pair<realm::Array *, std::__1::default_delete<realm::Array> > __ptr_;
} unique_ptr<realm::Array, std::__1::default_delete<realm::Array> >;

typedef struct BpTree<long long> {
	unique_ptr<realm::Array, std::__1::default_delete<realm::Array> > m_root;
} BpTree<long long>;

typedef struct _compressed_pair<realm::StringIndex *, std::__1::default_delete<realm::StringIndex> > {
	StringIndex __value_;
} compressed_pair<realm::StringIndex *, std::__1::default_delete<realm::StringIndex> >;

typedef struct unique_ptr<realm::StringIndex, std::__1::default_delete<realm::StringIndex> > {
	compressed_pair<realm::StringIndex *, std::__1::default_delete<realm::StringIndex> > __ptr_;
} unique_ptr<realm::StringIndex, std::__1::default_delete<realm::StringIndex> >;

typedef struct Column<long long> {
	/*function pointer*/void* _vptr$ColumnBase;
	unsigned long long m_column_ndx;
	unique_ptr<realm::StringIndex, std::__1::default_delete<realm::StringIndex> > m_search_index;
	BpTree<long long> m_tree;
} Column<long long>;

typedef struct TableView {
	/*function pointer*/void* _vptr$RowIndexes;
	Column<long long> m_row_indexes;
	unsigned long long m_limit_count;
	unsigned long long m_debug_cookie;
	BasicTableRef<realm::Table> m_table;
	BacklinkColumn m_linked_column;
	BasicRow<const realm::Table> m_linked_row;
	shared_ptr<const realm::LinkView> m_linkview_source;
	unsigned long long m_distinct_column_source;
	DescriptorOrdering m_descriptor_ordering;
	Query m_query;
	unsigned long long m_start;
	unsigned long long m_end;
	unsigned long long m_limit;
	Optional<unsigned long long> m_last_seen_version;
	unsigned long long m_num_detached_refs;
} TableView;

typedef struct Results {
	shared_ptr<realm::Realm> m_realm;
	ObjectSchema m_object_schema;
	Query m_query;
	TableView m_table_view;
	shared_ptr<realm::LinkView> m_link_view;
	BasicTableRef<realm::Table> m_table;
	DescriptorOrdering m_descriptor_ordering;
	Handle<realm::_impl::ResultsNotifier> m_notifier;
	int m_mode;
	int m_update_policy;
	BOOL m_has_used_table_view;
	BOOL m_wants_background_updates;
} Results;

typedef struct shared_ptr<realm::_impl::CollectionNotifier> {
	CollectionNotifier __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<realm::_impl::CollectionNotifier>;

typedef struct AtomicSharedPtr<realm::_impl::CollectionNotifier, true> {
	shared_ptr<realm::_impl::CollectionNotifier> m_ptr;
} AtomicSharedPtr<realm::_impl::CollectionNotifier, true>;

typedef struct NotificationToken {
	AtomicSharedPtr<realm::_impl::CollectionNotifier, true> m_notifier;
	unsigned long long m_token;
} NotificationToken;

typedef struct _compressed_pair<realm::IndexSet *, std::__1::allocator<realm::IndexSet> > {
	IndexSet __value_;
} compressed_pair<realm::IndexSet *, std::__1::allocator<realm::IndexSet> >;

typedef struct vector<realm::IndexSet, std::__1::allocator<realm::IndexSet> > {
	IndexSet __begin_;
	IndexSet __end_;
	compressed_pair<realm::IndexSet *, std::__1::allocator<realm::IndexSet> > __end_cap_;
} vector<realm::IndexSet, std::__1::allocator<realm::IndexSet> >;

typedef struct _compressed_pair<realm::CollectionChangeSet::Move *, std::__1::allocator<realm::CollectionChangeSet::Move> > {
	Move __value_;
} compressed_pair<realm::CollectionChangeSet::Move *, std::__1::allocator<realm::CollectionChangeSet::Move> >;

typedef struct vector<realm::CollectionChangeSet::Move, std::__1::allocator<realm::CollectionChangeSet::Move> > {
	Move __begin_;
	Move __end_;
	compressed_pair<realm::CollectionChangeSet::Move *, std::__1::allocator<realm::CollectionChangeSet::Move> > __end_cap_;
} vector<realm::CollectionChangeSet::Move, std::__1::allocator<realm::CollectionChangeSet::Move> >;

typedef struct _compressed_pair<realm::_impl::ChunkedRangeVector::Chunk *, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> > {
	Chunk __value_;
} compressed_pair<realm::_impl::ChunkedRangeVector::Chunk *, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> >;

typedef struct vector<realm::_impl::ChunkedRangeVector::Chunk, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> > {
	Chunk __begin_;
	Chunk __end_;
	compressed_pair<realm::_impl::ChunkedRangeVector::Chunk *, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> > __end_cap_;
} vector<realm::_impl::ChunkedRangeVector::Chunk, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> >;

typedef struct IndexSet {
	vector<realm::_impl::ChunkedRangeVector::Chunk, std::__1::allocator<realm::_impl::ChunkedRangeVector::Chunk> > m_data;
} IndexSet;

typedef struct CollectionChangeSet {
	IndexSet deletions;
	IndexSet insertions;
	IndexSet modifications;
	IndexSet modifications_new;
	vector<realm::CollectionChangeSet::Move, std::__1::allocator<realm::CollectionChangeSet::Move> > moves;
	vector<realm::IndexSet, std::__1::allocator<realm::IndexSet> > columns;
} CollectionChangeSet;

typedef struct _compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > {
	unsigned long long __value_;
} compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> >;

typedef struct _compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true> > {
	unsigned long long __value_;
} compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true> >;

typedef struct _compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true> > {
	float __value_;
} compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true> >;

typedef struct _hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> {
	__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> __next_;
} hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *>;

typedef struct _compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> > > {
	hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> __value_;
} compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> > >;

typedef struct _bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > {
	compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > __data_;
} bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> >;

typedef struct _compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > > {
	__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> __value_;
	bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > __value_;
} compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > >;

typedef struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > > {
	compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > > __ptr_;
} unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > >;

typedef struct _hash_table<std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, realm::IndexSet> > > {
	unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *> *> > > __bucket_list_;
	compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, realm::IndexSet>, void *> > > __p1_;
	compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true> > __p2_;
	compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true> > __p3_;
} hash_table<std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, realm::IndexSet> > >;

typedef struct unordered_map<NSString *, realm::IndexSet, std::__1::hash<NSString *>, std::__1::equal_to<NSString *>, std::__1::allocator<std::__1::pair<NSString *const, realm::IndexSet> > > {
	hash_table<std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, realm::IndexSet>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, realm::IndexSet> > > __table_;
} unordered_map<NSString *, realm::IndexSet, std::__1::hash<NSString *>, std::__1::equal_to<NSString *>, std::__1::allocator<std::__1::pair<NSString *const, realm::IndexSet> > >;

typedef struct _NSZone* NSZoneRef;

typedef struct BasicRow<realm::Table> {
	BasicTableRef<realm::Table> m_table;
	unsigned long long m_row_ndx;
	RowBase m_prev;
	RowBase m_next;
} BasicRow<realm::Table>;

typedef struct Handle<realm::_impl::ObjectNotifier> {
	ObjectNotifier __ptr_;
	__shared_weak_count __cntrl_;
} Handle<realm::_impl::ObjectNotifier>;

typedef struct Object {
	shared_ptr<realm::Realm> m_realm;
	ObjectSchema m_object_schema;
	BasicRow<realm::Table> m_row;
	Handle<realm::_impl::ObjectNotifier> m_notifier;
} Object;

typedef struct _compressed_pair<(anonymous namespace)::OptionalBase *, std::__1::default_delete<(anonymous namespace)::OptionalBase> > {
	OptionalBase __value_;
} compressed_pair<(anonymous namespace)::OptionalBase *, std::__1::default_delete<(anonymous namespace)::OptionalBase> >;

typedef struct unique_ptr<(anonymous namespace)::OptionalBase, std::__1::default_delete<(anonymous namespace)::OptionalBase> > {
	compressed_pair<(anonymous namespace)::OptionalBase *, std::__1::default_delete<(anonymous namespace)::OptionalBase> > __ptr_;
} unique_ptr<(anonymous namespace)::OptionalBase, std::__1::default_delete<(anonymous namespace)::OptionalBase> >;

typedef struct objc_ivar* objc_ivarRef;

typedef struct objc_property* objc_propertyRef;

typedef struct _compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > {
	unsigned long long __value_;
} compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> >;

typedef struct _compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true> > {
	unsigned long long __value_;
} compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true> >;

typedef struct _compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true> > {
	float __value_;
} compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true> >;

typedef struct _hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> {
	__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> __next_;
} hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *>;

typedef struct _compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> > > {
	hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> __value_;
} compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> > >;

typedef struct _bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > {
	compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > __data_;
} bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> >;

typedef struct _compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > > {
	__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> __value_;
	bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > __value_;
} compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > >;

typedef struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > > {
	compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > > __ptr_;
} unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > >;

typedef struct _hash_table<std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, RLMClassInfo> > > {
	unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *> *> > > __bucket_list_;
	compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<NSString *, RLMClassInfo>, void *> > > __p1_;
	compressed_pair<unsigned long, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true> > __p2_;
	compressed_pair<float, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true> > __p3_;
} hash_table<std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, RLMClassInfo> > >;

typedef struct unordered_map<NSString *, RLMClassInfo, std::__1::hash<NSString *>, std::__1::equal_to<NSString *>, std::__1::allocator<std::__1::pair<NSString *const, RLMClassInfo> > > {
	hash_table<std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::__unordered_map_hasher<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::hash<NSString *>, true>, std::__1::__unordered_map_equal<NSString *, std::__1::__hash_value_type<NSString *, RLMClassInfo>, std::__1::equal_to<NSString *>, true>, std::__1::allocator<std::__1::__hash_value_type<NSString *, RLMClassInfo> > > __table_;
} unordered_map<NSString *, RLMClassInfo, std::__1::hash<NSString *>, std::__1::equal_to<NSString *>, std::__1::allocator<std::__1::pair<NSString *const, RLMClassInfo> > >;

typedef struct RLMSchemaInfo {
	unordered_map<NSString *, RLMClassInfo, std::__1::hash<NSString *>, std::__1::equal_to<NSString *>, std::__1::allocator<std::__1::pair<NSString *const, RLMClassInfo> > > m_objects;
} RLMSchemaInfo;

typedef struct _compressed_pair<RLMResultsSetInfo *, std::__1::default_delete<RLMResultsSetInfo> > {
	RLMResultsSetInfo __value_;
} compressed_pair<RLMResultsSetInfo *, std::__1::default_delete<RLMResultsSetInfo> >;

typedef struct unique_ptr<RLMResultsSetInfo, std::__1::default_delete<RLMResultsSetInfo> > {
	compressed_pair<RLMResultsSetInfo *, std::__1::default_delete<RLMResultsSetInfo> > __ptr_;
} unique_ptr<RLMResultsSetInfo, std::__1::default_delete<RLMResultsSetInfo> >;

typedef struct BinaryData {
	char* m_data;
	unsigned long long m_size;
} BinaryData;

typedef struct _compressed_pair<char *, std::__1::allocator<char> > {
	char* __value_;
} compressed_pair<char *, std::__1::allocator<char> >;

typedef struct type {
	unsigned char __lx[24];
} type;

typedef struct Optional<unsigned long> {
	/*function pointer*/void* ;
	unsigned long long m_value;
	c) m_null_state;
	BOOL m_engaged;
} Optional<unsigned long>;

typedef struct _value_func<std::__1::shared_ptr<realm::AuditInterface> ()> {
	type __buf_;
	__base<std::__1::shared_ptr<realm::AuditInterface> ()> __f_;
} value_func<std::__1::shared_ptr<realm::AuditInterface> ()>;

typedef struct function<std::__1::shared_ptr<realm::AuditInterface> ()> {
	value_func<std::__1::shared_ptr<realm::AuditInterface> ()> __f_;
} function<std::__1::shared_ptr<realm::AuditInterface> ()>;

typedef struct shared_ptr<realm::SyncConfig> {
	SyncConfig __ptr_;
	__shared_weak_count __cntrl_;
} shared_ptr<realm::SyncConfig>;

typedef struct _value_func<bool (unsigned long long, unsigned long long)> {
	type __buf_;
	__base<bool (unsigned long long, unsigned long long)> __f_;
} value_func<bool (unsigned long long, unsigned long long)>;

typedef struct function<bool (unsigned long long, unsigned long long)> {
	value_func<bool (unsigned long long, unsigned long long)> __f_;
} function<bool (unsigned long long, unsigned long long)>;

typedef struct _value_func<void (std::__1::shared_ptr<realm::Realm>)> {
	type __buf_;
	__base<void (std::__1::shared_ptr<realm::Realm>)> __f_;
} value_func<void (std::__1::shared_ptr<realm::Realm>)>;

typedef struct function<void (std::__1::shared_ptr<realm::Realm>)> {
	value_func<void (std::__1::shared_ptr<realm::Realm>)> __f_;
} function<void (std::__1::shared_ptr<realm::Realm>)>;

typedef struct _value_func<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)> {
	type __buf_;
	__base<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)> __f_;
} value_func<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)>;

typedef struct function<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)> {
	value_func<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)> __f_;
} function<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)>;

typedef struct _compressed_pair<realm::ObjectSchema *, std::__1::allocator<realm::ObjectSchema> > {
	ObjectSchema __value_;
} compressed_pair<realm::ObjectSchema *, std::__1::allocator<realm::ObjectSchema> >;

typedef struct Schema {
	ObjectSchema __begin_;
	ObjectSchema __end_;
	compressed_pair<realm::ObjectSchema *, std::__1::allocator<realm::ObjectSchema> > __end_cap_;
} Schema;

typedef struct Optional<realm::Schema> {
	/*function pointer*/void* ;
	Schema m_value;
	c) m_null_state;
	BOOL m_engaged;
} Optional<realm::Schema>;

typedef struct vector<char, std::__1::allocator<char> > {
	char* __begin_;
	char* __end_;
	compressed_pair<char *, std::__1::allocator<char> > __end_cap_;
} vector<char, std::__1::allocator<char> >;

typedef struct Config {
	basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > path;
	BinaryData realm_data;
	vector<char, std::__1::allocator<char> > encryption_key;
	basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > fifo_files_fallback_path;
	BOOL in_memory;
	unsigned char schema_mode;
	Optional<realm::Schema> schema;
	unsigned long long schema_version;
	function<void (std::__1::shared_ptr<realm::Realm>, std::__1::shared_ptr<realm::Realm>, realm::Schema &)> migration_function;
	function<void (std::__1::shared_ptr<realm::Realm>)> initialization_function;
	function<bool (unsigned long long, unsigned long long)> should_compact_on_launch_function;
	BOOL cache;
	BOOL disable_format_upgrade;
	BOOL automatic_change_notifications;
	Optional<unsigned long> execution_context;
	shared_ptr<realm::SyncConfig> sync_config;
	BOOL force_sync_history;
	function<std::__1::shared_ptr<realm::AuditInterface> ()> audit_factory;
} Config;

typedef struct _compressed_pair<realm::ThreadSafeReferenceBase *, std::__1::default_delete<realm::ThreadSafeReferenceBase> > {
	ThreadSafeReferenceBase __value_;
} compressed_pair<realm::ThreadSafeReferenceBase *, std::__1::default_delete<realm::ThreadSafeReferenceBase> >;

typedef struct unique_ptr<realm::ThreadSafeReferenceBase, std::__1::default_delete<realm::ThreadSafeReferenceBase> > {
	compressed_pair<realm::ThreadSafeReferenceBase *, std::__1::default_delete<realm::ThreadSafeReferenceBase> > __ptr_;
} unique_ptr<realm::ThreadSafeReferenceBase, std::__1::default_delete<realm::ThreadSafeReferenceBase> >;

typedef struct CGFont* CGFontRef;

typedef const struct __CTFont* CTFontRef;

typedef struct os_unfair_lock_s {
	unsigned _os_unfair_lock_opaque;
} os_unfair_lock_s;

typedef struct {
	unsigned preferredStyle : 1;
} SCD_Struct_WF105;

typedef struct __CFRunLoop* CFRunLoopRef;

typedef struct CGSize {
	double width;
	double height;
} CGSize;

